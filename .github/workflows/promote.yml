name: Promote Service

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Source environment to promote from (qa/uat)'
        required: true
        type: choice
        options:
          - qa
          - uat
      service:
        description: 'Service to promote'
        required: true
        type: choice
        options:
          - frontend
          - post-service
          - user-service
          - comment-service

jobs:
  promote:
    runs-on: ubuntu-latest
    env:
      # Set default values to avoid empty variable issues
      TARGET_ENV: "not-set"
      SOURCE_TAG_SUFFIX: "not-set"
      TARGET_TAG_SUFFIX: "not-set"
    
    steps:
      # Step 1: Determine target environment & tag suffixes
      - name: Set target environment variables
        run: |
          SOURCE_ENV="${{ github.event.inputs.environment }}"
          
          if [ "$SOURCE_ENV" == "qa" ]; then
            echo "TARGET_ENV=uat" >> $GITHUB_ENV
            echo "SOURCE_TAG_SUFFIX=qa" >> $GITHUB_ENV
            echo "TARGET_TAG_SUFFIX=rc" >> $GITHUB_ENV
          elif [ "$SOURCE_ENV" == "uat" ]; then
            echo "TARGET_ENV=prod" >> $GITHUB_ENV
            echo "SOURCE_TAG_SUFFIX=rc" >> $GITHUB_ENV
            echo "TARGET_TAG_SUFFIX=" >> $GITHUB_ENV
          else
            echo "Error: Invalid source environment: $SOURCE_ENV"
            exit 1
          fi
      
      # Step 2: Verify variables are set correctly
      - name: Verify environment variables
        run: |
          echo "Source environment: ${{ github.event.inputs.environment }}"
          echo "Target environment: ${{ env.TARGET_ENV }}"
          echo "Source tag suffix: ${{ env.SOURCE_TAG_SUFFIX }}"
          echo "Target tag suffix: ${{ env.TARGET_TAG_SUFFIX }}"
          
          # Double-check that variables are set
          if [ "${{ env.TARGET_ENV }}" == "not-set" ]; then
            echo "Error: TARGET_ENV is not set correctly"
            exit 1
          fi

      # Step 3: Configure AWS
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Step 4: Login to ECR
      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      # Step 5: Promote image (tag & push)
      - name: Promote service image
        id: promote-image
        run: |
          # Service info
          SERVICE="${{ github.event.inputs.service }}"
          SOURCE_ENV="${{ github.event.inputs.environment }}"
          TARGET_ENV="${{ env.TARGET_ENV }}"
          SOURCE_TAG_SUFFIX="${{ env.SOURCE_TAG_SUFFIX }}"
          TARGET_TAG_SUFFIX="${{ env.TARGET_TAG_SUFFIX }}"
          
          echo "Promoting $SERVICE from $SOURCE_ENV to $TARGET_ENV"
          
          # Find the latest versioned image with the right tag suffix
          SOURCE_IMAGE=$(aws ecr describe-images \
            --repository-name blog-platform/$SERVICE \
            --query "imageDetails[?imageTags && contains(imageTags, \`latest-${SOURCE_TAG_SUFFIX}\`)].[imageTags, imageDigest]" \
            --output json | jq -r '.[0][0][] | select(contains("latest-'${SOURCE_TAG_SUFFIX}'") | not) | select(contains("-'${SOURCE_TAG_SUFFIX}'"))' | sort -V | tail -n 1)
          
          if [ -z "$SOURCE_IMAGE" ]; then
            echo "Error: Could not find source image for $SERVICE in $SOURCE_ENV"
            exit 1
          fi
          
          # Get core version without environment suffix
          VERSION=$(echo $SOURCE_IMAGE | sed "s/-${SOURCE_TAG_SUFFIX}//")
          echo "Found source image: $SOURCE_IMAGE (core version: $VERSION)"
          
          # Get the image digest for reliable referencing
          IMAGE_DIGEST=$(aws ecr describe-images \
            --repository-name blog-platform/$SERVICE \
            --query "imageDetails[?imageTags && contains(imageTags, \`${SOURCE_IMAGE}\`)].imageDigest" \
            --output text)
          
          if [ -z "$IMAGE_DIGEST" ]; then
            echo "Error: Could not find image digest"
            exit 1
          fi
          
          # Create target tags based on target environment
          ECR_URL="${{ secrets.ECR_URL }}"
          SOURCE_URI="${ECR_URL}/blog-platform/${SERVICE}@${IMAGE_DIGEST}"
          
          # Set proper tags based on target environment
          if [ "$TARGET_ENV" == "prod" ]; then
            # Production tags
            TARGET_TAGS=("$VERSION" "latest" "stable")
            DEPLOY_VERSION="$VERSION"
          else
            # UAT tags
            TARGET_TAGS=("${VERSION}-${TARGET_TAG_SUFFIX}" "latest-${TARGET_TAG_SUFFIX}")
            DEPLOY_VERSION="${VERSION}-${TARGET_TAG_SUFFIX}"
          fi
          
          # Pull the source image
          docker pull --platform=linux/arm64 $SOURCE_URI
          
          # Tag and push with all appropriate tags
          for TARGET_TAG in "${TARGET_TAGS[@]}"; do
            TARGET_URI="${ECR_URL}/blog-platform/${SERVICE}:${TARGET_TAG}"
            echo "Tagging and pushing: $TARGET_URI"
            
            docker tag $SOURCE_URI $TARGET_URI
            docker push $TARGET_URI
          done
          
          # Set output for next step
          echo "DEPLOY_VERSION=$DEPLOY_VERSION" >> $GITHUB_ENV
          echo "Successfully promoted $SERVICE from $SOURCE_ENV to $TARGET_ENV with version $DEPLOY_VERSION"

      # Step 6: Verify variables for deployment
      - name: Prepare for deployment
        run: |
          echo "Service: ${{ github.event.inputs.service }}"
          echo "Target environment: ${{ env.TARGET_ENV }}"
          echo "Deploy version: ${{ env.DEPLOY_VERSION }}"
          
          if [ -z "${{ env.DEPLOY_VERSION }}" ]; then
            echo "Error: Deploy version is not set"
            exit 1
          fi

      # Step 7: Trigger deployment workflow
      - name: Trigger deployment workflow
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GH_ACCESS_TOKEN }}
          script: |
            // Access environment variables directly
            const targetEnv = process.env.TARGET_ENV;
            const deployVersion = process.env.DEPLOY_VERSION;
            const service = '${{ github.event.inputs.service }}';
            
            console.log(`Deploying ${service} to ${targetEnv} with version ${deployVersion}`);
            
            // Create the deploy info object with properly escaped values
            const deployInfo = {
              images: { [service]: deployVersion },
              changed_services: [service]
            };
            
            // Trigger the deployment workflow
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'deploy.yml',
              ref: context.ref,
              inputs: {
                environment: targetEnv,
                deploy_info: JSON.stringify(deployInfo)
              }
            });
            
            console.log(`Successfully triggered deployment to ${targetEnv}`);